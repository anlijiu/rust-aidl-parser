grammar<'err>(
    lookup: &line_col::LineColLookup<'input>,
    diagnostics: &'err mut Vec<Diagnostic>
);

use crate::ast;
use crate::diagnostic::{Diagnostic, DiagnosticKind};
use crate::javadoc;

pub OptFile: Option<ast::File> = {
    <p:Package> <vi:Import*> <oi:OptItem> => {
        oi.map(|item| ast::File {
            package: p,
            imports: vi,
            item,
        })
    }
}

// e.g. package x.y.z;
pub(crate) Package: ast::Package = {
    PACKAGE <p1:@L> <name:QualifiedName> <p2:@R> ";" => {
        ast::Package {
            name,
            symbol_range: ast::Range::new(lookup, p1, p2),
        }
    }
}

// e.g. import x.y.z;
pub(crate) Import: ast::Import = {
    IMPORT <p1:@L> <v:(<IDENT> ".")+> <n:IDENT> <p2:@R> ";" => {
        ast::Import {
            path: v.join("."),
            name: n.to_owned(),
            symbol_range: ast::Range::new(lookup, p1, p2),
        }
    }
}

// e.g. x OR x.y.z
QualifiedName: String = {
    <v:(<IDENT> ".")*> <n:IDENT> => {
        if v.is_empty() {
            n.to_owned()
        } else {
            format!("{}.{}", v.join("."), n)
        }
    }
}

// Interface, parcelable or enum
OptItem: Option<ast::Item> = {
    <i:Interface> => Some(ast::Item::Interface(i)),
    <p:Parcelable> => Some(ast::Item::Parcelable(p)),
    <e:Enum> => Some(ast::Item::Enum(e)),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid item", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. interface Xyz { ... }
pub(crate) Interface: ast::Interface = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> INTERFACE <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:OptInterfaceElement*> "}" <fp2:@R> => {
        // Convert Vec<Option<InterfaceElement>> into Vec<InterfaceElement>
        let elements: Vec<ast::InterfaceElement> = v.into_iter().flatten().collect();

        ast::Interface {
            name: s.into(),
            elements,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Method or const (with error recovery)
OptInterfaceElement: Option<ast::InterfaceElement> = {
    <m:Method> => Some(ast::InterfaceElement::Method(m)),
    <c:Const> => Some(ast::InterfaceElement::Const(c)),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid interface element", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. parcelable Xyz { ... }
pub(crate) Parcelable: ast::Parcelable = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> PARCELABLE <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:OptParcelableMember*> "}" <fp2:@R> => {
        // Convert Vec<Option<Member>> into Vec<Member>
        let members: Vec<ast::Member> = v.into_iter().flatten().collect();

        ast::Parcelable {
            name: s.into(),
            members,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Parcelable member
OptParcelableMember: Option<ast::Member> = {
    <m:Member> => Some(m),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid member", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. enum Xyz { ... }
pub(crate) Enum: ast::Enum = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> ENUM <sp1:@L> <s:IDENT> <sp2:@R> "{" <v:CommaSeparated<OptEnumElement>> "}" <fp2:@R> => {
        // Convert Vec<Option<EnumElement>> into Vec<EnumElement>
        let elements: Vec<ast::EnumElement> = v.into_iter().flatten().collect();

        ast::Enum {
            name: s.into(),
            elements,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// Enum element (with error recovery)
OptEnumElement: Option<ast::EnumElement> = {
    <el:EnumElement> => Some(el),
    ! =>? {
        if let Some(d) = Diagnostic::from_error_recovery("Invalid enum element", lookup, <>) {
            diagnostics.push(d);
        }
        Ok(None)
    },
}

// e.g. @Annotation String myMethod(...) = 2;
pub(crate) Method: ast::Method = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> <oneway:ONEWAY?> <rt:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    "(" <args:CommaSeparated<Arg>> ")"
    <vp1:@L> <v:("=" <NUMBER>)?> <vp2:@R>  // TODO: only [0-9]+
    <fp2:@R> ";" => {
        ast::Method {
            oneway: oneway.is_some(),
            name: n.to_owned(),
            return_type: rt,
            args,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            value: match v.map(str::parse) {
                Some(Ok(v)) => Some(v),
                Some(Err(e)) => {
                    diagnostics.push(Diagnostic {
                        kind: DiagnosticKind::Error,
                        range: ast::Range::new(&lookup, vp1 + 2, vp2),
                        message: format!("Invalid method value: {}", e),
                        context_message: None,
                        hint: None,
                        related_infos: Vec::new(),
                    });
                    None
                },
                None => None,
            },
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// e.g. @Annotation inout MyType argName
pub(crate) Arg: ast::Arg = {
    <p0:@L>
    <d:Direction> 
    <annotations:AnnotationList>
    <t:Type> <n:IDENT?> => {
        ast::Arg {
            direction: d,
            name: n.map(str::to_owned),
            arg_type: t,
            annotations,
            doc: javadoc::get_javadoc(input, p0),
        }
    }
}

// Arg direction (in, out or inout)
Direction: ast::Direction = {
    <d:DIRECTION?> => {
        match d {
            Some("in") => ast::Direction::In,
            Some("out") => ast::Direction::Out,
            Some("inout") => ast::Direction::InOut,
            None => ast::Direction::Unspecified,
            _ => unreachable!(),
        }
    }
}

// e.g. @Annotation const int XYZ = 3;
pub(crate) Const: ast::Const = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> CONST <t:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    "=" <v:Value>
    <fp2:@R> ";" => {
        ast::Const {
            name: n.to_owned(),
            const_type: t,
            value: v.to_owned(),
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    },
}

// e.g. @Annotation String myMember;
pub(crate) Member: ast::Member = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L> <t:Type>
    <sp1:@L> <n:IDENT> <sp2:@R>
    <v:("=" <Value>)?>
    <fp2:@R> ";" => {
        ast::Member {
            name: n.to_owned(),
            member_type: t,
            value: v.map(str::to_owned),
            annotations,
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

// e.g. @Annotation ELEMENT = 3
EnumElement: ast::EnumElement = {
    <p0:@L>
    <annotations:AnnotationList>
    <fp1:@L>
    <sp1:@L> <n:IDENT> <sp2:@R>
    <v:("=" <Value>)?>
    <fp2:@R> => {
        ast::EnumElement {
            name: n.to_owned(),
            value: v.map(str::to_owned),
            doc: javadoc::get_javadoc(input, p0),
            full_range: ast::Range::new(&lookup, fp1, fp2),
            symbol_range: ast::Range::new(&lookup, sp1, sp2),
        }
    }
}

pub(crate) Type: ast::Type = {
    TypeVoid,
    TypePrimitive,
    TypeString,
    TypeArray,
    TypeList,
    TypeMap,
    TypeCustom,
}

TypeVoid: ast::Type = {
    <p1:@L> <n:VOID> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::Void, lookup, p1, p2)
}

TypePrimitive: ast::Type = {
    <p1:@L> <n:PRIMITIVE> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::Primitive, lookup, p1, p2)
}

TypeString: ast::Type = {
    <p1:@L> <n:STRING> <p2:@R> =>
        ast::Type::simple_type(n, ast::TypeKind::String, lookup, p1, p2)
}

TypeArray: ast::Type = {
    <p1:@L> <pp1:@L> <p:TypeArrayParameterValid> <pp2:@R> "[" "]" <p2:@L> => {
        ast::Type::array(p, &lookup, p1, p2)
    },
    <p1:@L> <pp1:@L> <p:TypeArrayParameterInvalid> "[" "]" <pp2:@R> <p2:@L> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Error,
            message: format!("Invalid array parameter: `{}`", p.name),
            context_message: Some("invalid parameter".to_owned()),
            range: ast::Range::new(&lookup, pp1, pp2),
            hint: Some("must be a primitive or an enum".to_owned()),
            related_infos: Vec::new(),
        });

        ast::Type::invalid_with_generics("Array", &[p], &lookup, p1, p2)
    },
}

// Types which can be used as an array (primitives)
//
// Note: as we don't know at this point if TypeCustom is an object (interface, parcelable)
// or a primitive (enum), we consider it to be valid.
TypeArrayParameterValid = {
    TypePrimitive,
    TypeCustom,
}

// Types which cannot be used as an array (non-primitives)
TypeArrayParameterInvalid = {
    TypeVoid,
    TypeString,
    TypeArray,
    TypeList,
    TypeMap,
}

TypeList: ast::Type = {
    <p1:@L> LIST "<" <p:TypeCollectionParameterValid> ">" <p2:@R> => {
        ast::Type::list(p, &lookup, p1, p2)
    },
    <p1:@L> LIST "<" <pp1:@L> <p:TypeCollectionParameterInvalid> <pp2:@R> ">" <p2:@R> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Error,
            message: format!("Invalid list parameter: `{}`", p.name),
            context_message: Some("invalid parameter".to_owned()),
            range: ast::Range::new(&lookup, pp1, pp2),
            hint: Some("must be an object".to_owned()),
            related_infos: Vec::new(),
        });
        ast::Type::invalid_with_generics("List", &[p], &lookup, p1, p2)
    },
}

// Parse Map and return TypeKind::Invalid if the parameters are not correct
TypeMap: ast::Type = {
    <p1:@L> MAP "<"
        <k:TypeCollectionParameterValid> "," <v:TypeCollectionParameterValid>
    ">" <p2:@R> => {
        ast::Type::map(k, v, &lookup, p1, p2)
    },
    <p1:@L> MAP "<"
        <kp1:@L> <k:TypeCollectionParameterInvalid> <kp2:@R> ","
        <v:TypeCollectionParameterValid>
    ">"  <p2:@R> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Error,
            message: format!("Invalid map key: {}", k.name),
            context_message: Some("invalid key".to_owned()),
            range: ast::Range::new(&lookup, kp1, kp2),
            hint: Some("key must be an object".to_owned()),
            related_infos: Vec::new(),
        });
        ast::Type::invalid_with_generics("Map", &[k, v], &lookup, p1, p2)
    },
    <p1:@L> MAP "<" <pp1:@L>
        <k:TypeCollectionParameterInvalid> "," <v:TypeCollectionParameterInvalid>
    <pp2:@R> ">" <p2:@R> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Error,
            message: format!("Invalid map parameters: {}, {}", k.name, v.name),
            context_message: Some("invalid parameters".to_owned()),
            range: ast::Range::new(&lookup, pp1, pp2),
            hint: Some("key and value must be objects".to_owned()),
            related_infos: Vec::new(),
        });
        ast::Type::invalid_with_generics("Map", &[k, v], &lookup, p1, p2)
    },
    <p1:@L> MAP "<"
        <k:TypeCollectionParameterValid> ","
        <vp1:@L> <v:TypeCollectionParameterInvalid> <vp2:@R>
    ">" <p2:@R> => {
        diagnostics.push(Diagnostic {
            kind: DiagnosticKind::Error,
            message: format!("Invalid map value: {}", v.name),
            context_message: Some("invalid value".to_owned()),
            range: ast::Range::new(&lookup, vp1, vp2),
            hint: Some("value must be an object".to_owned()),
            related_infos: Vec::new(),
        });
        ast::Type::invalid_with_generics("Map", &[k, v], &lookup, p1, p2)
    },
}

// Types which can be used as a List or Map generic parameter (objects)
//
// Note: as we don't know at this point if TypeCustom is an object (interface, parcelable)
// or a primitive (enum), we consider it to be valid.
TypeCollectionParameterValid = {
    TypeString,
    TypeList,
    TypeMap,
    TypeCustom,
}

// Types which cannot be used as a List or Map generic parameter (non-objects)
TypeCollectionParameterInvalid = {
    TypeVoid,
    TypePrimitive,
    TypeArray,
}

// Unresolved custom type (should be an interface, a parcelable or an enum)
TypeCustom: ast::Type = {
    <p1:@L> <n:QualifiedName> <p2:@R> => {
        ast::Type {
            name: n.to_owned(),
            kind: ast::TypeKind::Custom,
            generic_types: vec![],
            definition: None,
            symbol_range: ast::Range::new(&lookup, p1, p2),
        }
    }
}

AnnotationList: Vec<ast::Annotation> = {
    // Convert Vec<Option<Annotation>> into Vec<Annotation>
    <v:OptAnnotation*> => v.into_iter().flatten().collect()
}

pub(crate) OptAnnotation: Option<ast::Annotation> = {
    <n:ANNOTATION> <v:("(" <CommaSeparated<AnnotationParam>> ")")?> => {
        Some(ast::Annotation {
            name: n.to_owned(),
            key_values: v.unwrap_or_default().into_iter().collect(),
        })
    },
}

AnnotationParam: (String, Option<String>) = {
    <k:IDENT> <v:("=" <Value>)?> => (k.to_owned(), v.map(str::to_owned))
}

pub(crate) Value: &'input str = {
    NUMBER,
    QUOTED_STRING,
    BOOLEAN,
    "{" "}" => "{}",
}

// Comma separated list with optional trailing comma
CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

// Tokens
match {
    // Whitespaces, comments, EOL
    r"\s*" => { }, // The default whitespace skipping is disabled and an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    
    "package" => PACKAGE,
    "import" => IMPORT,
    "interface" => INTERFACE,
    "parcelable" => PARCELABLE,
    "enum" => ENUM,
    "oneway" => ONEWAY,
    "const" => CONST,
    
    r"(in|out|inout)" => DIRECTION,
    "void" => VOID,
    r"(byte|short|int|long|float|double|boolean|char)" => PRIMITIVE,
    r"(String|CharSequence)" => STRING,
    "List" => LIST,
    "Map" => MAP,
    
    r#""[^"\n\r]*""# => QUOTED_STRING,
    r#"(true|false)"# => BOOLEAN,

    r"@[a-zA-Z_][a-zA-Z0-9_]*" => ANNOTATION,
    
    // Signs
    ";",  ",", "{", "}", "(", ")", "[", "]", "<", ">", "=", ".", "-",
} else {
    // Other
    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENT,
    r"[+-]?(\d*\.)?\d+[f]?" => NUMBER,
} else {
    r"[0-9]" => DIGIT,
} else {
    //r"[^;]*;" => ANY_INTERFACE_ELEMENT,  // TODO
}
